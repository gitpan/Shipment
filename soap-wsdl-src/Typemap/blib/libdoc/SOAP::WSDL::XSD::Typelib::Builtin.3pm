.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SOAP::WSDL::XSD::Typelib::Builtin 3"
.TH SOAP::WSDL::XSD::Typelib::Builtin 3 "2010-10-06" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SOAP::WSDL::XSD::Typelib::Builtin \- Built\-in XML Schema datatypes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The SOAP::WSDL::XSD::Typelib::Builtin hierarchy implements all builtin types
from the \s-1XML\s0 schema specification.
.PP
All \s-1XML\s0 schema derived types inherit from
SOAP::WSDL::XSD::Typelib::Builtin::anyType.
.PP
These basic type classes are most useful when used as element or simpleType
base classes.
.PP
Using SOAP::WSDL::XSD::Typelib::Builtin uses all of the builtin datatype
classes.
.PP
All builtin types feature common behaviour described below in
\&\*(L"\s-1OVERLOADED\s0 \s-1OPERATORS\s0\*(R"
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\& my $bool = SOAP::WSDL::XSD::Typelib::Builtin::bool\->new({ value => 0} );
\& print $bool;    # prints "true"
\&
\& # implements <simpleType name="MySimpleType">
\& #               <list itemType="xsd:string" />
\& #            </simpleType>
\& package MySimpleType;
\& use SOAP::WSDL::XSD::Typelib::Builtin;
\& use SOAP::WSDL::XSD::Typelib::SimpleType;
\&
\& use base qw(SOAP::WSDL::XSD::Typelib::SimpleType
\&    SOAP::WSDL::XSD::Typelib::Builtin::list
\&    SOAP::WSDL::XSD::Typelib::Builtin::string
\& );
\& 1;
\&
\& # somewhere else
\& my $list = MySimpleType\->new({ value => [ \*(AqYou\*(Aq, \*(Aqshall\*(Aq, \*(Aqovercome\*(Aq ] });
\& print $list;   # prints "You shall overcome"
.Ve
.SH "CLASS HIERARCHY"
.IX Header "CLASS HIERARCHY"
This is the inheritance graph for builtin types.
.PP
Types with [] marker describe types derived via the item in [] in the \s-1XML\s0
Schema specs.
.PP
Derivation is implemented via multiple inheritance with the derivation method
as first item in the base class list.
.PP
.Vb 10
\& anyType
\& \- anySimpleType
\&     \- duration
\&     \- dateTime
\&     \- date
\&     \- time
\&     \- gYearMonth
\&     \- gYear
\&     \- gMonthDay
\&     \- gDay
\&     \- gMonth
\&     \- boolean
\&     \- base64Binary
\&     \- hexBinary
\&     \- float
\&     \- decimal
\&         \- integer
\&         \- nonPositiveInteger
\&             \- negativeInteger
\&         \- nonNegativeInteger
\&             \- positiveInteger
\&             \- unsignedLong
\&             \- unsignedInt
\&             \- unsignedShort
\&             \- unsignedByte
\&         \- long
\&             \- int
\&                 \- short
\&                     \- byte
\&     \- double
\&     \- anyURI
\&     \- NOTATION
\&     \- string
\&          \- normalizedString
\&              \- language
\&              \- Name
\&                  \- NCName
\&                      \- ID
\&                      \- IDREF
\&                          \- IDREFS [list]
\&                      \- ENTITY
\&              \- token
\&                  \- NMTOKEN
\&                      \- NMTOKENS [list]
.Ve
.SH "OVERLOADED OPERATORS"
.IX Header "OVERLOADED OPERATORS"
Overloading is implemented via Class::Std's trait mechanism.
.PP
The following behaviours apply:
.IP "\(bu" 4
string context
.Sp
All classes use the \f(CW\*(C`serialize\*(C'\fR method for stringification.
.IP "\(bu" 4
bool context
.Sp
All classes derived from anySimpleType return their value in bool context
.IP "\(bu" 4
numeric context
.Sp
The boolean class returns 0 or 1 in numeric context.
.Sp
decimal, float and double (and derived classes) return their value in
numeric context.
.IP "\(bu" 4
arrayification (@{})
.Sp
When accessed as a list ref, objects of all classes return a list ref with
the object itself as single element.
.Sp
This is most useful for writing loops without additional conversions,
especially in mini-languages found in templating systems or the like, which
may not natively support converting to list refs.
.Sp
Instead of writing something like
.Sp
.Vb 3
\& my $value = $complexType\->get_ELEMENT;
\& $value = ref $value eq \*(AqARRAY\*(Aq ? $value : [ $value ];
\& for (@{ $value }) { ... }
.Ve
.Sp
you can just write
.Sp
.Vb 1
\& for (@{ $complexType\->get_ELEMENT }) {...}
.Ve
.Sp
Note that complexTypes with undef elements still return undef when accessing
an undefined element, so when an element may be empty you still have to write
something like:
.Sp
.Vb 6
\& my $value = $complexType\->get_ELEMENT();
\& if (defined $value) {
\&     for (@{ $value }) {
\&         ...
\&     }
\& }
.Ve
.SH "Subclasses"
.IX Header "Subclasses"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::anyType"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::anyType"
Base class for all types
.SS "SOAP::WSDL::XSD::Typelib::Builtin::anySimpleType"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::anySimpleType"
Base class for all simple types
.SS "SOAP::WSDL::XSD::Typelib::Builtin::anyURI"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::anyURI"
Type representing URIs
.SS "SOAP::WSDL::XSD::Typelib::Builtin::boolean"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::boolean"
Represents boolean data.
.PP
Serializes to \*(L"true\*(R" or \*(L"false\*(R".
.PP
Everything true in perl and not \*(L"false\*(R" is deserialized as true.
.PP
Returns true/false in boolean context.
.PP
Returns 1 / 0 in numeric context.
.PP
boolean objects have a special method for deleting their value, because
calling \f(CW\*(C`setl_value(undef)\*(C'\fR results in the value being set to false.
.PP
.Vb 1
\& $obj\->delete_value();
.Ve
.SS "SOAP::WSDL::XSD::Typelib::Builtin::byte"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::byte"
byte integer objects.
.SS "SOAP::WSDL::XSD::Typelib::Builtin::date"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::date"
date values are automatically converted into \s-1XML\s0 date strings during setting:
.PP
.Vb 1
\& YYYY\-MM\-DD+zz:zz
.Ve
.PP
The time zone is set to the local time zone if not included.
.PP
All input variants supported by Date::Parse are supported. You may even pass
in dateTime strings \- the time part will be ignored. Note that
set_value is around 100 times slower when setting non-XML-time strings
.PP
When setting dates before the beginning of the epoch (negative \s-1UNIX\s0 timestamp),
you should use the \s-1XML\s0 date string format for setting dates. The behaviour of
Date::Parse for dates before the epoch is system dependent.
.SS "SOAP::WSDL::XSD::Typelib::Builtin::dateTime"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::dateTime"
dateTime values are automatically converted into \s-1XML\s0 dateTime strings during setting:
.PP
.Vb 1
\& YYYY\-MM\-DDThh:mm:ss.nnnnnnn+zz:zz
.Ve
.PP
The fraction of seconds (nnnnnnn) part is optional. Fractions of seconds may
be given with arbitrary precision
.PP
The fraction of seconds part is excluded in converted values, as it would always be 0.
.PP
All input variants supported by Date::Parse are supported. Note that
set_value is around 100 times slower when setting non-XML-time strings
.SS "SOAP::WSDL::XSD::Typelib::Builtin::decimal"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::decimal"
decimal is the base of all non-float numbers
.SS "SOAP::WSDL::XSD::Typelib::Builtin::double"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::double"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::duration"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::duration"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::ENTITY"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::ENTITY"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::float"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::float"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::gDay"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::gDay"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::gMonth"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::gMonth"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::gMonthDay"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::gMonthDay"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::gYear"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::gYear"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::gYearMonth"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::gYearMonth"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::hexBinary"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::hexBinary"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::ID"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::ID"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::IDREF"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::IDREF"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::IDREFS"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::IDREFS"
List of SOAP::WSDL::XSD::Typelib::Builtin::IDREF objects.
.PP
Derived by SOAP::WSDL::XSD::Typelib::Builtin::list.
.SS "SOAP::WSDL::XSD::Typelib::Builtin::int"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::int"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::integer"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::integer"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::language"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::language"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::list"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::list"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::long"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::long"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::Name"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::Name"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::NCName"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::NCName"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::negativeInteger"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::negativeInteger"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::nonNegativeInteger"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::nonNegativeInteger"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::nonPositiveInteger"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::nonPositiveInteger"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::normalizedString"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::normalizedString"
Tab, newline and carriage return characters are replaced by whitespace in
set_value.
.SS "SOAP::WSDL::XSD::Typelib::Builtin::NOTATION"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::NOTATION"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::positiveInteger"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::positiveInteger"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::QName"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::QName"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::short"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::short"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::string"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::string"
String values are XML-escaped on serialization.
.PP
The following characters are escaped: <, >, &
.SS "SOAP::WSDL::XSD::Typelib::Builtin::time"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::time"
time values are automatically converted into \s-1XML\s0 time strings during setting:
.PP
.Vb 2
\& hh:mm:ss.nnnnnnn+zz:zz
\& hh:mm:ss+zz:zz
.Ve
.PP
The time zone is set to the local time zone if not included. The optional
nanoseconds part is not included in converted values, as it would always be 0.
.PP
All input variants supported by Date::Parse are supported. You may even pass
in dateTime strings \- the date part will be ignored. Note that
set_value is around 100 times slower when setting non-XML-time strings.
.SS "SOAP::WSDL::XSD::Typelib::Builtin::token"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::token"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::unsignedByte"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::unsignedByte"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::unsignedInt"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::unsignedInt"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::unsignedLong"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::unsignedLong"
.SS "SOAP::WSDL::XSD::Typelib::Builtin::unsignedShort"
.IX Subsection "SOAP::WSDL::XSD::Typelib::Builtin::unsignedShort"
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
set_value
.Sp
In contrast to Class::Std\-generated mutators (setters), set_value does
not return the last value.
.Sp
This is for speed reasons: \s-1SOAP::WSDL\s0 never needs to know the last value
when calling set_calue, but calls it over and over again...
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.IP "\(bu" 4
Thread safety
.Sp
SOAP::WSDL::XSD::Typelib::Builtin uses Class::Std::Fast::Storable which uses
Class::Std. Class::Std is not thread safe, so
SOAP::WSDL::XSD::Typelib::Builtin is neither.
.IP "\(bu" 4
\&\s-1XML\s0 Schema facets
.Sp
No facets are implemented yet.
.SH "AUTHOR"
.IX Header "AUTHOR"
Replace whitespace by @ in e\-mail address.
.PP
.Vb 1
\& Martin Kutter E<gt>martin.kutter fen\-net.deE<lt>
.Ve
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2004\-2007 Martin Kutter.
.PP
This file is part of SOAP-WSDL. You may distribute/modify it under the
same terms as perl itself
